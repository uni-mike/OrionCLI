#!/usr/bin/env node

// Comprehensive test for ToolForge - tests all features
const fs = require('fs').promises;
const path = require('path');
const { execSync } = require('child_process');

// Direct testing without spawning OrionCLI
const ToolForge = require('./src/experimental/tool-forge');
const ToolForgeIntegration = require('./src/experimental/tool-forge-integration');
const colors = require('./src/utils/colors');

// Mock tool registry
const mockRegistry = {
  executeTool: async (name, args) => {
    throw new Error(`Tool not found: ${name}`);
  }
};

// Mock client info
const mockClientInfo = {
  createClient: function() {
    return {
      chat: {
        completions: {
          create: async (params) => {
            // Mock AI responses based on the prompt
            const userMessage = params.messages[params.messages.length - 1].content;
            if (userMessage.includes('Analyze this error')) {
              return {
                choices: [{
                  message: {
                    content: JSON.stringify({
                      toolName: "calculate_hash",
                      functionality: "Calculate hash of a file",
                      parameters: ["filename", "algorithm"],
                      returnType: "string",
                      category: "file_ops"
                    })
                  }
                }]
              };
            } else if (userMessage.includes('Generate a JavaScript tool')) {
              return {
                choices: [{
                  message: {
                    content: `
class CalculateHash {
  constructor() {
    this.name = 'calculate_hash';
    this.description = 'Calculate hash of a file';
  }
  
  async execute(args) {
    if (!args.filename) {
      throw new Error('filename parameter required');
    }
    
    const crypto = require('crypto');
    const fs = require('fs').promises;
    
    try {
      const content = await fs.readFile(args.filename, 'utf8');
      const algorithm = args.algorithm || 'sha256';
      const hash = crypto.createHash(algorithm).update(content).digest('hex');
      
      return {
        output: \`Hash (\${algorithm}): \${hash}\`,
        hash: hash,
        algorithm: algorithm
      };
    } catch (error) {
      throw new Error(\`Failed to calculate hash: \${error.message}\`);
    }
  }
}

module.exports = CalculateHash;`
                  }
                }]
              };
            }
            return { choices: [{ message: { content: '{}' } }] };
          }
        }
      }
    };
  },
  config: {}
};

async function testToolForge() {
  console.log(colors.primary('üß™ COMPREHENSIVE TOOLFORGE TEST'));
  console.log(colors.dim('='.repeat(60)));
  
  const results = {
    passed: [],
    failed: []
  };
  
  // Clean up any previous test artifacts
  try {
    await execSync('rm -rf .tool-forge');
  } catch (e) {}
  
  // Initialize ToolForge
  console.log('\n' + colors.info('üì¶ Phase 1: Initialization'));
  const forge = new ToolForge(mockClientInfo, mockRegistry);
  const integration = new ToolForgeIntegration();
  
  try {
    await forge.init();
    await integration.init(mockClientInfo, mockRegistry);
    console.log(colors.success('‚úÖ ToolForge initialized'));
    results.passed.push('Initialization');
  } catch (error) {
    console.log(colors.error('‚ùå Initialization failed:', error.message));
    results.failed.push('Initialization');
    return results;
  }
  
  // Test 1: Detect missing tool error
  console.log('\n' + colors.info('üîç Phase 2: Missing Tool Detection'));
  const testError1 = new Error('Tool not found: calculate_hash');
  const isMissing = integration.isMissingToolError(testError1);
  
  if (isMissing) {
    console.log(colors.success('‚úÖ Missing tool detected correctly'));
    results.passed.push('Missing tool detection');
  } else {
    console.log(colors.error('‚ùå Failed to detect missing tool'));
    results.failed.push('Missing tool detection');
  }
  
  // Test 2: Generate tool from error
  console.log('\n' + colors.info('üî® Phase 3: Tool Generation'));
  try {
    const success = await forge.forge(testError1, {
      toolCall: { function: { name: 'calculate_hash', arguments: '{"filename":"test.txt"}' } }
    });
    
    if (success) {
      console.log(colors.success('‚úÖ Tool generated successfully'));
      results.passed.push('Tool generation');
      
      // Verify the tool was created
      const manifest = forge.manifest;
      if (manifest.tools.calculate_hash) {
        console.log(colors.success('‚úÖ Tool registered in manifest'));
        console.log(colors.dim(`   Version: ${manifest.tools.calculate_hash.activeVersion}`));
        results.passed.push('Tool registration');
      } else {
        console.log(colors.error('‚ùå Tool not found in manifest'));
        results.failed.push('Tool registration');
      }
    } else {
      console.log(colors.error('‚ùå Tool generation failed'));
      results.failed.push('Tool generation');
    }
  } catch (error) {
    console.log(colors.error('‚ùå Tool generation error:', error.message));
    results.failed.push('Tool generation');
  }
  
  // Test 3: Version tracking
  console.log('\n' + colors.info('üìö Phase 4: Version Tracking'));
  try {
    const versions = await forge.listVersions('calculate_hash');
    if (versions && versions.length > 0) {
      console.log(colors.success(`‚úÖ Version tracking works: ${versions.length} version(s)`));
      versions.forEach(v => {
        console.log(colors.dim(`   v${v.version} - ${v.created} ${v.active ? '(active)' : ''}`));
        console.log(colors.dim(`     Notes: ${v.notes}`));
      });
      results.passed.push('Version tracking');
    } else {
      console.log(colors.error('‚ùå No versions found'));
      results.failed.push('Version tracking');
    }
  } catch (error) {
    console.log(colors.error('‚ùå Version tracking error:', error.message));
    results.failed.push('Version tracking');
  }
  
  // Test 4: Create second version
  console.log('\n' + colors.info('üîÑ Phase 5: Multiple Versions'));
  try {
    // Simulate generating an updated version
    const toolInfo = await forge.generateTool({
      toolName: 'calculate_hash',
      functionality: 'Calculate hash with improved performance',
      parameters: ['filename', 'algorithm', 'encoding'],
      returnType: 'object',
      category: 'file_ops'
    });
    
    if (toolInfo) {
      // Mock test as passed
      forge.manifest.tools.calculate_hash.versions.push({
        version: toolInfo.version,
        path: toolInfo.path,
        spec: toolInfo.spec,
        created: new Date().toISOString(),
        testsPassed: true
      });
      forge.manifest.tools.calculate_hash.activeVersion = toolInfo.version;
      await forge.saveManifest();
      
      console.log(colors.success('‚úÖ Second version created'));
      console.log(colors.dim(`   New version: ${toolInfo.version}`));
      results.passed.push('Multiple versions');
      
      // List versions again
      const versions = await forge.listVersions('calculate_hash');
      console.log(colors.dim(`   Total versions: ${versions.length}`));
    }
  } catch (error) {
    console.log(colors.warning('‚ö†Ô∏è Multiple versions test skipped'));
  }
  
  // Test 5: Rollback
  console.log('\n' + colors.info('‚è™ Phase 6: Rollback Mechanism'));
  try {
    const versions = await forge.listVersions('calculate_hash');
    if (versions.length > 1) {
      const currentVersion = forge.manifest.tools.calculate_hash.activeVersion;
      const success = await forge.rollback('calculate_hash');
      
      if (success) {
        const newActiveVersion = forge.manifest.tools.calculate_hash.activeVersion;
        if (newActiveVersion !== currentVersion) {
          console.log(colors.success('‚úÖ Rollback successful'));
          console.log(colors.dim(`   Rolled back from v${currentVersion} to v${newActiveVersion}`));
          results.passed.push('Rollback');
        } else {
          console.log(colors.error('‚ùå Rollback did not change version'));
          results.failed.push('Rollback');
        }
      } else {
        console.log(colors.error('‚ùå Rollback failed'));
        results.failed.push('Rollback');
      }
    } else {
      console.log(colors.warning('‚ö†Ô∏è Not enough versions to test rollback'));
    }
  } catch (error) {
    console.log(colors.error('‚ùå Rollback error:', error.message));
    results.failed.push('Rollback');
  }
  
  // Test 6: History tracking
  console.log('\n' + colors.info('üìú Phase 7: History Tracking'));
  try {
    const history = forge.manifest.history;
    if (history && history.length > 0) {
      console.log(colors.success(`‚úÖ History tracking: ${history.length} entries`));
      history.slice(-3).forEach(entry => {
        console.log(colors.dim(`   ${entry.action} ${entry.tool} v${entry.version}`));
      });
      results.passed.push('History tracking');
    } else {
      console.log(colors.error('‚ùå No history found'));
      results.failed.push('History tracking');
    }
  } catch (error) {
    console.log(colors.error('‚ùå History tracking error:', error.message));
    results.failed.push('History tracking');
  }
  
  // Test 7: Cleanup old versions
  console.log('\n' + colors.info('üßπ Phase 8: Cleanup'));
  try {
    await forge.cleanup(1); // Keep only 1 version
    const versions = await forge.listVersions('calculate_hash');
    if (versions.length <= 1) {
      console.log(colors.success('‚úÖ Cleanup successful'));
      console.log(colors.dim(`   Versions remaining: ${versions.length}`));
      results.passed.push('Cleanup');
    } else {
      console.log(colors.warning(`‚ö†Ô∏è Expected 1 version, found ${versions.length}`));
    }
  } catch (error) {
    console.log(colors.error('‚ùå Cleanup error:', error.message));
    results.failed.push('Cleanup');
  }
  
  // Test 8: Integration features
  console.log('\n' + colors.info('üîó Phase 9: Integration Features'));
  try {
    // Test failure patterns
    integration.failureHistory = [
      { error: 'Tool not found: test1', context: {}, timestamp: new Date().toISOString() },
      { error: 'Tool not found: test1', context: {}, timestamp: new Date().toISOString() },
      { error: 'Tool not found: test2', context: {}, timestamp: new Date().toISOString() }
    ];
    
    const patterns = integration.getFailurePatterns();
    if (patterns.length > 0) {
      console.log(colors.success('‚úÖ Failure pattern analysis works'));
      console.log(colors.dim(`   Top pattern: ${patterns[0].pattern} (${patterns[0].count} times)`));
      results.passed.push('Failure patterns');
    }
    
    // Test forged tools list
    const forgedTools = await integration.listForgedTools();
    if (forgedTools.length > 0) {
      console.log(colors.success(`‚úÖ Listed ${forgedTools.length} forged tool(s)`));
      results.passed.push('List forged tools');
    }
  } catch (error) {
    console.log(colors.error('‚ùå Integration features error:', error.message));
    results.failed.push('Integration features');
  }
  
  // Test 9: Manifest persistence
  console.log('\n' + colors.info('üíæ Phase 10: Persistence'));
  try {
    // Save current manifest
    await forge.saveManifest();
    
    // Create new instance and load
    const forge2 = new ToolForge(mockClientInfo, mockRegistry);
    await forge2.init();
    
    if (forge2.manifest.tools.calculate_hash) {
      console.log(colors.success('‚úÖ Manifest persisted and loaded'));
      results.passed.push('Persistence');
    } else {
      console.log(colors.error('‚ùå Manifest not persisted correctly'));
      results.failed.push('Persistence');
    }
  } catch (error) {
    console.log(colors.error('‚ùå Persistence error:', error.message));
    results.failed.push('Persistence');
  }
  
  return results;
}

// Run comprehensive test
async function main() {
  console.clear();
  console.log(colors.primary.bold('\nüöÄ TOOLFORGE COMPREHENSIVE TEST SUITE\n'));
  
  const startTime = Date.now();
  const results = await testToolForge();
  const duration = ((Date.now() - startTime) / 1000).toFixed(2);
  
  // Summary
  console.log('\n' + colors.primary('='.repeat(60)));
  console.log(colors.primary.bold('\nüìä TEST SUMMARY\n'));
  
  console.log(colors.success(`‚úÖ Passed: ${results.passed.length}`));
  results.passed.forEach(test => {
    console.log(colors.dim(`   ‚Ä¢ ${test}`));
  });
  
  if (results.failed.length > 0) {
    console.log(colors.error(`\n‚ùå Failed: ${results.failed.length}`));
    results.failed.forEach(test => {
      console.log(colors.dim(`   ‚Ä¢ ${test}`));
    });
  }
  
  const successRate = Math.round((results.passed.length / (results.passed.length + results.failed.length)) * 100);
  
  console.log('\n' + colors.primary('='.repeat(60)));
  console.log(colors.info(`\n‚è±Ô∏è  Duration: ${duration}s`));
  console.log(colors.info(`üìà Success Rate: ${successRate}%`));
  
  if (successRate === 100) {
    console.log(colors.success.bold('\nüéâ ALL TESTS PASSED! ToolForge is fully functional!\n'));
  } else if (successRate >= 80) {
    console.log(colors.warning.bold('\n‚úÖ MOSTLY PASSED - Some features need attention\n'));
  } else {
    console.log(colors.error.bold('\n‚ö†Ô∏è  NEEDS WORK - Several features are not working\n'));
  }
  
  // Verify files created
  console.log(colors.dim('\nüìÅ Artifacts created:'));
  try {
    const manifestExists = await fs.stat('.tool-forge/manifest.json');
    console.log(colors.dim('   ‚Ä¢ .tool-forge/manifest.json'));
    
    const files = await fs.readdir('.tool-forge/versions/').catch(() => []);
    if (files.length > 0) {
      console.log(colors.dim(`   ‚Ä¢ ${files.length} version file(s) in .tool-forge/versions/`));
    }
  } catch (e) {}
  
  // Clean up option
  console.log(colors.dim('\nCleanup: rm -rf .tool-forge'));
  
  process.exit(successRate === 100 ? 0 : 1);
}

main().catch(error => {
  console.error(colors.error('\nüí• Test suite crashed:'), error);
  process.exit(1);
});
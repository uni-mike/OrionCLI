# 🔧 ToolForge System - Experimental Self-Improving Tools

## 🚀 Overview
ToolForge is OrionCLI's experimental self-improving tool creation system. When enabled, it can automatically generate, test, and register new tools when the AI encounters missing functionality.

## ⚠️ Important Notes
- **Status**: Experimental - use with caution
- **Purpose**: Automatic tool creation and improvement
- **Location**: `/src/experimental/tool-forge-integration.js`
- **Default**: Disabled (must be explicitly enabled)

## 🎯 How It Works

### **1. Missing Tool Detection**
When the AI tries to use a tool that doesn't exist, ToolForge:
1. Detects the missing tool error
2. Analyzes what the tool should do based on context
3. Generates a new tool implementation
4. Tests it in a sandbox environment
5. Registers it for immediate use

### **2. Tool Versioning**
- Every tool change creates a new version
- Full version history is maintained
- Easy rollback to any previous version
- Changelog notes for each version

### **3. Self-Improvement**
- Tools can be automatically updated when they fail
- Performance monitoring and enhancement
- Smart error recovery and adaptation

## 🛠️ Usage Commands

### **Enable/Disable ToolForge**
```bash
/forge                    # Toggle ToolForge on/off
```

### **Manage Forged Tools**
```bash
/forge-list              # List all created tools with versions
/forge-rollback <tool>   # Rollback to previous version
/forge-rollback <tool> <version>  # Rollback to specific version
```

## 📋 ToolForge Workflow

### **Automatic Tool Creation Process**
1. **Error Detection**: AI encounters missing tool
2. **Context Analysis**: ToolForge analyzes the intended use
3. **Tool Generation**: Creates tool using gpt-5 model
4. **Sandbox Testing**: Tests in isolated environment
5. **Registration**: Adds to active tool registry
6. **Immediate Use**: Tool is available for current operation
7. **Version Tracking**: Saves as version 1.0

### **Tool Improvement Process**
1. **Failure Detection**: Existing tool fails or performs poorly
2. **Analysis**: Understand why it failed
3. **Enhancement**: Generate improved version
4. **Testing**: Verify improvements work
5. **Deployment**: Update active version
6. **History**: Previous version remains available

## 🔧 Technical Architecture

### **Core Components**
```
src/experimental/
├── tool-forge-integration.js  # Main integration
├── tool-forge.js             # Core ToolForge engine  
└── versions/                 # Version storage
    ├── manifest.json         # Tool registry
    └── tools/               # Individual tool files
        ├── custom-tool-v1.js
        ├── custom-tool-v2.js
        └── ...
```

### **Integration Points**
- **OrionToolRegistry**: Registers forged tools
- **Error Handling**: Catches missing tool errors
- **AI Models**: Uses gpt-5 for tool generation
- **Sandbox**: Safe testing environment

## 📊 Example Scenarios

### **Scenario 1: Missing Tool**
```bash
User: "Compress this directory into a zip file"
AI: Tries to use compress_directory tool
System: Tool doesn't exist
ToolForge: 
  1. Analyzes: Need zip compression functionality
  2. Generates: Tool using zip command
  3. Tests: Create test zip file
  4. Registers: compress_directory v1.0
  5. Executes: Successfully compresses directory
```

### **Scenario 2: Tool Improvement**
```bash
User: "Extract this tar.gz file"  
AI: Uses extract_archive tool (created earlier)
Tool: Fails on .tar.gz format (only handled .zip)
ToolForge:
  1. Detects: Tool failed on .tar.gz
  2. Analyzes: Need tar.gz support
  3. Enhances: Adds tar command support
  4. Tests: Extract test .tar.gz file
  5. Updates: extract_archive v2.0
  6. Executes: Successfully extracts tar.gz
```

## 🎨 Generated Tool Examples

### **Basic Tool Structure**
```javascript
// Auto-generated by ToolForge v1.0
module.exports = {
  name: 'custom_tool_name',
  description: 'Generated tool description',
  parameters: {
    param1: { type: 'string', description: 'Parameter description' },
    param2: { type: 'boolean', description: 'Optional parameter' }
  },
  
  async execute(args) {
    // Generated implementation
    const { param1, param2 } = args;
    
    // Tool logic here
    
    return {
      success: true,
      output: 'Tool execution result'
    };
  },
  
  // Metadata
  version: '1.0',
  created: '2024-01-01T00:00:00Z',
  updated: '2024-01-01T00:00:00Z',
  forged: true
};
```

## 🔒 Safety Features

### **Sandbox Testing**
- All generated tools are tested in isolation
- Cannot access sensitive system resources during testing
- Automatic rollback if tests fail

### **Permission System**
- Respects OrionCLI permission settings
- Asks for approval before creating potentially dangerous tools
- Maintains audit log of all forged tools

### **Version Control**
- Every change creates new version
- Complete rollback capability
- Change tracking and notes

## 📈 Usage Statistics

### **Track ToolForge Activity**
```bash
/forge-list    # Shows:
- Number of forged tools
- Version counts
- Recent activity
- Success rates
```

### **Example Output**
```
🔧 Forged Tools:
  • compress_directory v2.0 (3 versions)
    - v2.0 (active): Added tar.gz support  
    - v1.0: Initial zip compression
  • extract_archive v1.0 (1 version)
    - v1.0 (active): Multi-format extraction
  • batch_rename v3.0 (5 versions)
    - v3.0 (active): Regex pattern support
    - v2.0: Added safety checks

Recent activity:
  [14:32] created batch_rename v1.0
  [14:45] updated batch_rename v2.0
  [15:10] created extract_archive v1.0
```

## ⚡ Performance Considerations

### **Impact on System**
- **Minimal**: Only activates on missing tools
- **Lazy Loading**: Tools generated on-demand
- **Efficient**: Caches generated tools
- **Smart**: Learns from previous generations

### **Generation Speed**
- Simple tools: 5-10 seconds
- Complex tools: 15-30 seconds  
- Cached tools: Instant access

## 🛡️ Best Practices

### **When to Enable ToolForge**
✅ **Good For:**
- Prototyping new workflows
- Handling edge cases
- Custom automation needs
- Learning new tool patterns

❌ **Avoid For:**
- Production systems without testing
- Critical operations
- When you need deterministic behavior
- Security-sensitive environments

### **Monitoring ToolForge**
1. **Regular Reviews**: Check `/forge-list` periodically
2. **Test Generated Tools**: Verify they work as expected
3. **Version Management**: Keep important versions
4. **Cleanup**: Remove unused tools

### **Rollback Strategy**
```bash
# If a tool starts misbehaving
/forge-rollback problematic_tool

# Or rollback to specific good version
/forge-rollback problematic_tool 2.0
```

## 🔬 Advanced Features

### **Custom Generation Prompts**
ToolForge can be configured with custom prompts for tool generation, allowing for:
- Domain-specific tools
- Consistent coding styles
- Security-focused implementations
- Performance-optimized solutions

### **Learning from Usage**
- Tracks which tools are used most
- Identifies common failure patterns
- Suggests improvements automatically
- Learns from user feedback

## 🎯 Future Enhancements

### **Planned Features**
- **Tool Sharing**: Export/import forged tools
- **Community Registry**: Share tools with other users
- **Advanced Testing**: More comprehensive sandbox
- **ML Improvements**: Better tool generation using usage data
- **Integration**: Direct GitHub integration for tool sharing

### **Experimental Ideas**
- **Auto-optimization**: Tools that improve themselves
- **Collaborative Tools**: Tools that work together
- **Predictive Generation**: Create tools before they're needed

## 📝 Troubleshooting

### **Common Issues**

**Issue**: "ToolForge failed to generate tool"
**Solution**: Check if gpt-5 is available, verify system permissions

**Issue**: "Generated tool doesn't work"
**Solution**: Use `/forge-rollback` to previous version, check error logs

**Issue**: "Too many tool versions"
**Solution**: Manually clean up old versions from `.tool-forge/` directory

### **Debug Mode**
```bash
DEBUG_TOOLS=1 node orion.js
# Shows detailed ToolForge generation process
```

## 🎉 Conclusion

ToolForge represents the cutting edge of self-improving AI systems. While experimental, it demonstrates how AI can extend its own capabilities dynamically, creating a truly adaptive development environment.

Use with curiosity but also caution - the future of AI-assisted development is being written with tools like ToolForge!

---

*Status: Experimental* ⚗️  
*Last Updated: 2024* 🔬